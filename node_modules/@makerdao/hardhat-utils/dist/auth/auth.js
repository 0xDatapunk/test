"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.testAuth = exports.getActiveWards = void 0;
const chai_1 = require("chai");
const hardhat_1 = require("hardhat");
const address_1 = require("../address");
/**
 * Gets all active wards of a given contract. Turns out that it's not so trivial since events might be quite misleading.
 * This implementation simply gets all wards even relied and filter the ones that are not active anymore.
 */
async function getActiveWards(_authContract, fromBlockOrBlockhash) {
    const authContract = _authContract;
    const relyEvents = await authContract.queryFilter(authContract.filters.Rely(), fromBlockOrBlockhash);
    const relies = relyEvents.map((r) => r.args.usr);
    const statusOfRelies = await Promise.all(relies.map(async (usr) => ({ usr, active: await authContract.wards(usr) })));
    const activeRelies = statusOfRelies.filter((s) => s.active.toNumber() === 1).map((s) => s.usr);
    return activeRelies;
}
exports.getActiveWards = getActiveWards;
/**
 * Tests given contract against standard auth test suite
 * @param strictErrorMsgs - does contract revert error messages with its name?
 */
function testAuth({ name, getDeployArgs, authedMethods, strictErrorMsgs = true, }) {
    const expectedErrorMsg = strictErrorMsgs ? `${name}/not-authorized` : `/not-authorized`;
    describe('auth', () => {
        async function deploy() {
            const [deployer] = await hardhat_1.ethers.getSigners();
            const contractFactory = await hardhat_1.ethers.getContractFactory(name);
            const deployTxReq = contractFactory.getDeployTransaction(...(await getDeployArgs()));
            const deployTx = await deployer.sendTransaction(deployTxReq);
            const deployReceipt = await deployTx.wait();
            const contract = (await hardhat_1.ethers.getContractAt(name, deployReceipt.contractAddress));
            return { deployer, contract, deployTx };
        }
        it('makes initially the deployer the only ward', async () => {
            const { deployer, contract, deployTx } = await deploy();
            chai_1.expect(await getActiveWards(contract)).to.be.deep.eq([deployer.address]);
            await chai_1.expect(deployTx).to.emit(contract, 'Rely').withArgs(deployer.address);
        });
        it('relies on new addresses', async () => {
            const { deployer, contract } = await deploy();
            const randomAddress = await address_1.getRandomAddress();
            const relyTx = await contract.rely(randomAddress);
            chai_1.expect((await getActiveWards(contract)).sort()).to.be.deep.eq([deployer.address, randomAddress].sort());
            await chai_1.expect(relyTx).to.emit(contract, 'Rely').withArgs(randomAddress);
        });
        it('denies old addresses', async () => {
            const { deployer, contract } = await deploy();
            const randomAddress = await address_1.getRandomAddress();
            await contract.rely(randomAddress);
            const denyTx = await contract.deny(deployer.address);
            chai_1.expect((await getActiveWards(contract)).sort()).to.be.deep.eq([randomAddress].sort());
            await chai_1.expect(denyTx).to.emit(contract, 'Deny').withArgs(deployer.address);
        });
        it('only a ward can change permissions', async () => {
            const { contract } = await deploy();
            const [_, unauthorized] = await hardhat_1.ethers.getSigners();
            const randomAddress = await address_1.getRandomAddress();
            await chai_1.expect(contract.connect(unauthorized).rely(randomAddress)).to.be.revertedWith(expectedErrorMsg);
            await chai_1.expect(contract.connect(unauthorized).deny(randomAddress)).to.be.revertedWith(expectedErrorMsg);
        });
        it('only a ward can run authed methods', async () => {
            const { contract } = await deploy();
            const [_, unauthorized] = await hardhat_1.ethers.getSigners();
            const contractWithUnauthorizedSigner = contract.connect(unauthorized);
            for (const authedMethod of authedMethods) {
                await chai_1.expect(authedMethod(contractWithUnauthorizedSigner)).to.be.revertedWith(expectedErrorMsg);
            }
        });
    });
}
exports.testAuth = testAuth;
//# sourceMappingURL=auth.js.map